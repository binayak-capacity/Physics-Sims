<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Relativity of Simultaneity - Einstein's Train</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0a0e1a; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
        }
        
        .top-bar {
            height: 50px;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 2px solid #3b82f6;
            display: flex;
            align-items: center;
            padding: 0 25px;
        }
        
        .top-bar-title {
            font-size: 20px;
            font-weight: 700;
            color: #f1f5f9;
            letter-spacing: 0.5px;
        }
        
        .top-bar-title span {
            color: #60a5fa;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            height: calc(100vh - 50px);
        }
        
        #canvas-container {
            flex: 1;
            height: 100%;
            min-width: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
        }
        
        #mainCanvas {
            width: 100%;
            height: 100%;
        }
        
        .side-panel {
            width: 320px;
            min-width: 320px;
            height: 100%;
            background: rgba(10, 14, 26, 0.95);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel-section {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 10px;
            padding: 15px;
        }
        
        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .stat-label {
            color: #94a3b8;
        }
        
        .stat-value {
            color: #f1f5f9;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            background: rgba(59, 130, 246, 0.2);
            padding: 4px 10px;
            border-radius: 4px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control label {
            color: #94a3b8;
            font-size: 12px;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .slider-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #f1f5f9;
            font-weight: 600;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            flex: 1;
            padding: 10px 14px;
            background: #3b82f6;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        .btn.secondary {
            background: rgba(148, 163, 184, 0.2);
        }
        
        .btn.secondary:hover {
            background: rgba(148, 163, 184, 0.3);
        }
        
        .spacetime-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #spacetimeCanvas {
            width: 100%;
            height: 150px;
            border-radius: 6px;
            background: rgba(10, 14, 26, 0.8);
        }
        
        .info-text {
            font-size: 11px;
            line-height: 1.6;
            color: #94a3b8;
        }
        
        .info-text p {
            margin-bottom: 10px;
        }
        
        .info-text .highlight {
            color: #60a5fa;
        }
        
        .reference-frames {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .frame-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: #94a3b8;
        }
        
        .frame-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .stats-divider {
            height: 1px;
            background: rgba(148, 163, 184, 0.2);
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="top-bar-title"><span>üöÇ</span> Einstein's Train Paradox</div>
    </div>
    
    <div class="main-content">
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
        
        <div class="side-panel">
            <div class="panel-section">
                <div class="panel-title">üéõÔ∏è Simulation Controls</div>
                <div class="control-group">
                    <div class="control">
                        <label>Speed (v/c):</label>
                        <div class="slider-row">
                            <input type="range" class="slider" id="speedSlider" min="0.1" max="0.95" step="0.05" value="0.5">
                            <span class="slider-value" id="speedValue">0.5</span>
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn" id="fireBtn">‚ö° Fire Lightning</button>
                        <button class="btn secondary" id="resetBtn">‚Ü∫ Reset</button>
                    </div>
                </div>
                
                <div class="stats-divider"></div>
                
                <div class="stat-group">
                    <div class="stat">
                        <span class="stat-label">Train Velocity:</span>
                        <span class="stat-value" id="velocity">0.5c</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Œ≥ (Lorentz Factor):</span>
                        <span class="stat-value" id="gamma">1.15</span>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üìä Spacetime Diagram</div>
                <div class="spacetime-container">
                    <canvas id="spacetimeCanvas"></canvas>
                </div>
                <div class="reference-frames" style="margin-top: 12px;">
                    <div class="frame-item">
                        <div class="frame-dot" style="background: #60a5fa;"></div>
                        <span>Platform Observer (stationary)</span>
                    </div>
                    <div class="frame-item">
                        <div class="frame-dot" style="background: #34d399;"></div>
                        <span>Train Observer (moving)</span>
                    </div>
                    <div class="frame-item">
                        <div class="frame-dot" style="background: #fbbf24;"></div>
                        <span>Lightning strikes</span>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title" style="color: #f472b6;">üöÇ About This Simulation</div>
                <div class="info-text">
                    <p>Two lightning bolts strike both ends of a moving train simultaneously in the platform frame. But the train observer, moving toward one strike and away from the other, sees them at different times.</p>
                    <p class="highlight">This demonstrates that simultaneity is relative - events simultaneous in one frame may not be in another!</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const spacetimeCanvas = document.getElementById('spacetimeCanvas');
        const stCtx = spacetimeCanvas.getContext('2d');
        
        let width, height;
        let animationTime = 0;
        let trainVelocity = 0.5; // fraction of c
        let lightningFired = false;
        let lightningTime = 0;
        let lightWavesA = [];
        let lightWavesB = [];
        
        const c = 300; // pixels per second (speed of light in our simulation)
        
        // Scale factor for the animation
        const scaleFactor = 1.2;
        
        // Train properties (scaled up)
        let trainX = 0;
        const trainLength = 400 * scaleFactor;
        const trainHeight = 70 * scaleFactor;
        
        // Platform properties
        let platformY;
        let trainY;
        let centerX, centerY;
        
        // Wheel rotation angle
        let wheelRotation = 0;
        
        // Lightning bolt data for persistence
        let lightningBoltA = [];
        let lightningBoltB = [];
        let lightningBranches = [];
        
        // Light detection
        let platformDetectionA = null;
        let platformDetectionB = null;
        let trainDetectionA = null;
        let trainDetectionB = null;
        
        function resize() {
            const container = document.getElementById('canvas-container');
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            
            // Center the animation vertically and horizontally
            centerX = width / 2;
            centerY = height / 2;
            
            // Position train in the center of the animation window
            trainY = centerY - trainHeight / 2;
            
            // Position platform observer much lower (in the bottom portion)
            platformY = height - 120;
            
            // Resize spacetime canvas
            const stContainer = spacetimeCanvas.parentElement;
            spacetimeCanvas.width = stContainer.clientWidth;
            spacetimeCanvas.height = 150;
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        // Controls
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const fireBtn = document.getElementById('fireBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        speedSlider.addEventListener('input', (e) => {
            trainVelocity = parseFloat(e.target.value);
            speedValue.textContent = trainVelocity.toFixed(2);
            updateStats();
        });
        
        fireBtn.addEventListener('click', fireLightning);
        resetBtn.addEventListener('click', reset);
        
        // Generate realistic lightning bolt path
        function generateLightningBolt(x1, y1, x2, y2, displacement, minSegmentLength) {
            const points = [{x: x1, y: y1}];
            
            function subdivide(start, end, disp) {
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                const dist = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                
                if (dist < minSegmentLength) {
                    return [start, end];
                }
                
                const offsetX = (Math.random() - 0.5) * disp;
                const mid = {x: midX + offsetX, y: midY};
                
                const left = subdivide(start, mid, disp * 0.6);
                const right = subdivide(mid, end, disp * 0.6);
                
                return [...left.slice(0, -1), ...right];
            }
            
            return subdivide({x: x1, y: y1}, {x: x2, y: y2}, displacement);
        }
        
        // Generate branch lightning
        function generateBranches(mainBolt, numBranches) {
            const branches = [];
            for (let i = 0; i < numBranches; i++) {
                const startIdx = Math.floor(Math.random() * (mainBolt.length - 2)) + 1;
                const startPoint = mainBolt[startIdx];
                const branchLength = 30 + Math.random() * 60;
                const angle = (Math.random() - 0.5) * Math.PI * 0.8;
                const endX = startPoint.x + Math.sin(angle) * branchLength;
                const endY = startPoint.y + Math.cos(angle) * branchLength * 0.5;
                
                const branch = generateLightningBolt(startPoint.x, startPoint.y, endX, endY, 15, 8);
                branches.push(branch);
            }
            return branches;
        }
        
        function fireLightning() {
            if (lightningFired) return;
            lightningFired = true;
            lightningTime = animationTime;
            
            // Create light waves from both ends of the train
            const trainCenter = centerX;
            const strikeA = trainCenter - trainLength / 2;
            const strikeB = trainCenter + trainLength / 2;
            
            lightWavesA = [{ x: strikeA, y: trainY + trainHeight / 2, radius: 0, startTime: animationTime }];
            lightWavesB = [{ x: strikeB, y: trainY + trainHeight / 2, radius: 0, startTime: animationTime }];
            
            // Generate lightning bolt paths
            lightningBoltA = generateLightningBolt(strikeA, 0, strikeA, trainY + trainHeight / 2, 50 * scaleFactor, 15);
            lightningBoltB = generateLightningBolt(strikeB, 0, strikeB, trainY + trainHeight / 2, 50 * scaleFactor, 15);
            
            // Generate branches
            lightningBranches = [
                ...generateBranches(lightningBoltA, 3),
                ...generateBranches(lightningBoltB, 3)
            ];
            
            // Reset detections
            platformDetectionA = null;
            platformDetectionB = null;
            trainDetectionA = null;
            trainDetectionB = null;
        }
        
        function reset() {
            lightningFired = false;
            lightWavesA = [];
            lightWavesB = [];
            lightningBoltA = [];
            lightningBoltB = [];
            lightningBranches = [];
            platformDetectionA = null;
            platformDetectionB = null;
            trainDetectionA = null;
            trainDetectionB = null;
            animationTime = 0;
        }
        
        function updateStats() {
            document.getElementById('velocity').textContent = trainVelocity.toFixed(2) + 'c';
            const gamma = 1 / Math.sqrt(1 - trainVelocity * trainVelocity);
            document.getElementById('gamma').textContent = gamma.toFixed(3);
        }
        
        function drawStars() {
            ctx.fillStyle = '#1e293b';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137.5) % width;
                const y = (i * 73.3) % (height * 0.3);
                const size = (i % 3) + 1;
                const alpha = 0.3 + Math.sin(animationTime * 2 + i) * 0.2;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function drawPlatform() {
            // Platform (scaled)
            const platformHeight = 20 * scaleFactor;
            ctx.fillStyle = '#1e3a5f';
            ctx.fillRect(0, platformY, width, platformHeight);
            
            // Platform lines
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2 * scaleFactor;
            ctx.setLineDash([20, 10]);
            ctx.beginPath();
            ctx.moveTo(0, platformY);
            ctx.lineTo(width, platformY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Platform observer - positioned on the platform
            const observerX = centerX;
            drawObserver(observerX, platformY - 35 * scaleFactor, '#60a5fa', 'Platform Observer');
            
            // Label for platform observer
            ctx.font = 'bold ' + (11 * scaleFactor) + 'px sans-serif';
            ctx.fillStyle = '#60a5fa';
            ctx.textAlign = 'center';
            ctx.fillText('Platform Observer (Stationary)', observerX, platformY + 40 * scaleFactor);
            ctx.textAlign = 'left';
        }
        
        function drawTrain() {
            const trainCenter = centerX;
            const trainLeft = trainCenter - trainLength / 2;
            
            // Update wheel rotation based on velocity
            wheelRotation += trainVelocity * 0.15;
            
            // Train body with gradient
            const gradient = ctx.createLinearGradient(trainLeft, trainY, trainLeft, trainY + trainHeight);
            gradient.addColorStop(0, '#2d4a3e');
            gradient.addColorStop(1, '#1a2f26');
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#34d399';
            ctx.lineWidth = 2 * scaleFactor;
            
            // Main body
            ctx.beginPath();
            ctx.roundRect(trainLeft, trainY, trainLength, trainHeight, 8 * scaleFactor);
            ctx.fill();
            ctx.stroke();
            
            // Windows with rotating effect (scaled)
            const windowCount = 6;
            const windowWidth = 35 * scaleFactor;
            const windowHeight = 22 * scaleFactor;
            const windowSpacing = trainLength / (windowCount + 1);
            
            for (let i = 0; i < windowCount; i++) {
                const wx = trainLeft + windowSpacing * (i + 0.5);
                const wy = trainY + 12 * scaleFactor;
                
                // Window frame
                ctx.fillStyle = 'rgba(52, 211, 153, 0.2)';
                ctx.fillRect(wx, wy, windowWidth, windowHeight);
                
                // Window glass with animated reflection
                ctx.save();
                ctx.beginPath();
                ctx.rect(wx, wy, windowWidth, windowHeight);
                ctx.clip();
                
                // Rotating light reflection inside window
                const reflectionAngle = wheelRotation * 0.5 + i * 0.5;
                const reflectX = wx + windowWidth / 2 + Math.cos(reflectionAngle) * windowWidth * 0.3;
                const reflectY = wy + windowHeight / 2 + Math.sin(reflectionAngle) * windowHeight * 0.3;
                
                const reflectionGradient = ctx.createRadialGradient(
                    reflectX, reflectY, 0,
                    reflectX, reflectY, windowWidth * 0.6
                );
                reflectionGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                reflectionGradient.addColorStop(0.5, 'rgba(52, 211, 153, 0.2)');
                reflectionGradient.addColorStop(1, 'rgba(52, 211, 153, 0.1)');
                
                ctx.fillStyle = reflectionGradient;
                ctx.fillRect(wx, wy, windowWidth, windowHeight);
                
                // Window divider (cross pattern)
                ctx.strokeStyle = 'rgba(52, 211, 153, 0.5)';
                ctx.lineWidth = 1 * scaleFactor;
                ctx.beginPath();
                ctx.moveTo(wx + windowWidth / 2, wy);
                ctx.lineTo(wx + windowWidth / 2, wy + windowHeight);
                ctx.moveTo(wx, wy + windowHeight / 2);
                ctx.lineTo(wx + windowWidth, wy + windowHeight / 2);
                ctx.stroke();
                
                ctx.restore();
                
                // Window border
                ctx.strokeStyle = '#34d399';
                ctx.lineWidth = 1.5 * scaleFactor;
                ctx.strokeRect(wx, wy, windowWidth, windowHeight);
            }
            
            // Wheels with rotation (scaled)
            ctx.fillStyle = '#1f2937';
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 3 * scaleFactor;
            const wheelRadius = 12 * scaleFactor;
            const wheelCount = 4;
            const wheelSpacing = trainLength / (wheelCount + 1);
            
            for (let i = 0; i < wheelCount; i++) {
                const wx = trainLeft + wheelSpacing * (i + 1);
                const wy = trainY + trainHeight + 8 * scaleFactor;
                
                // Wheel body
                ctx.beginPath();
                ctx.arc(wx, wy, wheelRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Wheel spokes (rotating)
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 2 * scaleFactor;
                const spokeCount = 6;
                for (let j = 0; j < spokeCount; j++) {
                    const angle = wheelRotation + (j * Math.PI * 2 / spokeCount);
                    ctx.beginPath();
                    ctx.moveTo(wx, wy);
                    ctx.lineTo(
                        wx + Math.cos(angle) * wheelRadius * 0.8,
                        wy + Math.sin(angle) * wheelRadius * 0.8
                    );
                    ctx.stroke();
                }
                
                // Wheel center hub
                ctx.fillStyle = '#374151';
                ctx.beginPath();
                ctx.arc(wx, wy, wheelRadius * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Train observer in center
            drawObserver(trainCenter, trainY + trainHeight / 2 - 12 * scaleFactor, '#34d399', 'Train Observer');
            
            // Velocity arrow
            if (trainVelocity > 0) {
                ctx.strokeStyle = '#34d399';
                ctx.fillStyle = '#34d399';
                ctx.lineWidth = 3 * scaleFactor;
                const arrowX = trainLeft + trainLength + 25 * scaleFactor;
                const arrowY = trainY + trainHeight / 2;
                const arrowLen = 50 * trainVelocity * scaleFactor;
                
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX + arrowLen, arrowY);
                ctx.stroke();
                
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(arrowX + arrowLen + 10 * scaleFactor, arrowY);
                ctx.lineTo(arrowX + arrowLen - 5 * scaleFactor, arrowY - 8 * scaleFactor);
                ctx.lineTo(arrowX + arrowLen - 5 * scaleFactor, arrowY + 8 * scaleFactor);
                ctx.closePath();
                ctx.fill();
                
                ctx.font = (11 * scaleFactor) + 'px sans-serif';
                ctx.fillText('v = ' + trainVelocity.toFixed(2) + 'c', arrowX + arrowLen / 2 - 20 * scaleFactor, arrowY - 15 * scaleFactor);
            }
        }
        
        function drawObserver(x, y, color, label) {
            // Head (scaled)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 10 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.strokeStyle = color;
            ctx.lineWidth = 3 * scaleFactor;
            ctx.beginPath();
            ctx.moveTo(x, y + 10 * scaleFactor);
            ctx.lineTo(x, y + 30 * scaleFactor);
            ctx.stroke();
            
            // Arms
            ctx.beginPath();
            ctx.moveTo(x - 12 * scaleFactor, y + 18 * scaleFactor);
            ctx.lineTo(x + 12 * scaleFactor, y + 18 * scaleFactor);
            ctx.stroke();
            
            // Legs
            ctx.beginPath();
            ctx.moveTo(x, y + 30 * scaleFactor);
            ctx.lineTo(x - 8 * scaleFactor, y + 42 * scaleFactor);
            ctx.moveTo(x, y + 30 * scaleFactor);
            ctx.lineTo(x + 8 * scaleFactor, y + 42 * scaleFactor);
            ctx.stroke();
        }
        
        function drawRealisticLightningBolt(points, alpha, isMain) {
            if (points.length < 2) return;
            
            // Outer glow
            ctx.strokeStyle = `rgba(200, 220, 255, ${alpha * 0.3})`;
            ctx.lineWidth = (isMain ? 12 : 6) * scaleFactor;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 30 * scaleFactor;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            
            // Middle glow (blue-white)
            ctx.strokeStyle = `rgba(180, 200, 255, ${alpha * 0.6})`;
            ctx.lineWidth = (isMain ? 6 : 3) * scaleFactor;
            ctx.shadowBlur = 20 * scaleFactor;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            
            // Core (bright white)
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = (isMain ? 3 : 1.5) * scaleFactor;
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 15 * scaleFactor;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        }
        
        function drawLightning() {
            if (!lightningFired) return;
            
            const trainCenter = centerX;
            const strikeA = trainCenter - trainLength / 2;
            const strikeB = trainCenter + trainLength / 2;
            const timeSinceFire = animationTime - lightningTime;
            
            // Draw lightning bolts (flash effect)
            if (timeSinceFire < 0.5) {
                const flashAlpha = Math.pow(1 - timeSinceFire / 0.5, 2);
                
                // Flash effect at strike points
                if (timeSinceFire < 0.1) {
                    const flashSize = (1 - timeSinceFire / 0.1) * 100 * scaleFactor;
                    
                    // Strike A flash
                    const flashGradientA = ctx.createRadialGradient(
                        strikeA, trainY + trainHeight / 2, 0,
                        strikeA, trainY + trainHeight / 2, flashSize
                    );
                    flashGradientA.addColorStop(0, `rgba(255, 255, 255, ${flashAlpha})`);
                    flashGradientA.addColorStop(0.3, `rgba(200, 220, 255, ${flashAlpha * 0.5})`);
                    flashGradientA.addColorStop(1, 'rgba(200, 220, 255, 0)');
                    ctx.fillStyle = flashGradientA;
                    ctx.beginPath();
                    ctx.arc(strikeA, trainY + trainHeight / 2, flashSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Strike B flash
                    const flashGradientB = ctx.createRadialGradient(
                        strikeB, trainY + trainHeight / 2, 0,
                        strikeB, trainY + trainHeight / 2, flashSize
                    );
                    flashGradientB.addColorStop(0, `rgba(255, 255, 255, ${flashAlpha})`);
                    flashGradientB.addColorStop(0.3, `rgba(200, 220, 255, ${flashAlpha * 0.5})`);
                    flashGradientB.addColorStop(1, 'rgba(200, 220, 255, 0)');
                    ctx.fillStyle = flashGradientB;
                    ctx.beginPath();
                    ctx.arc(strikeB, trainY + trainHeight / 2, flashSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw main lightning bolts
                drawRealisticLightningBolt(lightningBoltA, flashAlpha, true);
                drawRealisticLightningBolt(lightningBoltB, flashAlpha, true);
                
                // Draw branches
                for (const branch of lightningBranches) {
                    drawRealisticLightningBolt(branch, flashAlpha * 0.7, false);
                }
            }
            
            // Draw expanding light waves (scaled speed)
            const waveRadius = timeSinceFire * c * scaleFactor;
            
            // Wave A - multiple rings for better effect
            for (let i = 0; i < 3; i++) {
                const ringRadius = waveRadius - i * 10;
                if (ringRadius > 0) {
                    const ringAlpha = Math.max(0, 0.6 - timeSinceFire * 0.2 - i * 0.15);
                    ctx.strokeStyle = `rgba(251, 191, 36, ${ringAlpha})`;
                    ctx.lineWidth = (3 - i) * scaleFactor;
                    ctx.beginPath();
                    ctx.arc(strikeA, trainY + trainHeight / 2, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Wave B - multiple rings
            for (let i = 0; i < 3; i++) {
                const ringRadius = waveRadius - i * 10;
                if (ringRadius > 0) {
                    const ringAlpha = Math.max(0, 0.6 - timeSinceFire * 0.2 - i * 0.15);
                    ctx.strokeStyle = `rgba(251, 191, 36, ${ringAlpha})`;
                    ctx.lineWidth = (3 - i) * scaleFactor;
                    ctx.beginPath();
                    ctx.arc(strikeB, trainY + trainHeight / 2, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Check detections
            const platformObserverX = centerX;
            const platformObserverY = platformY - 35 * scaleFactor;
            const trainObserverX = trainCenter;
            const trainObserverY = trainY + trainHeight / 2 - 12 * scaleFactor;
            
            // Distance calculations
            const distPlatformA = Math.sqrt(Math.pow(platformObserverX - strikeA, 2) + Math.pow(platformObserverY - (trainY + trainHeight / 2), 2));
            const distPlatformB = Math.sqrt(Math.pow(platformObserverX - strikeB, 2) + Math.pow(platformObserverY - (trainY + trainHeight / 2), 2));
            
            // For train observer, account for relative motion (scaled)
            const trainMovement = timeSinceFire * trainVelocity * c * scaleFactor;
            const effectiveDistTrainA = trainLength / 2 + trainMovement;
            const effectiveDistTrainB = trainLength / 2 - trainMovement;
            
            // Platform observer sees both simultaneously (equidistant)
            if (waveRadius >= distPlatformA && !platformDetectionA) {
                platformDetectionA = animationTime;
            }
            if (waveRadius >= distPlatformB && !platformDetectionB) {
                platformDetectionB = animationTime;
            }
            
            // Train observer - light from B arrives first (moving toward it)
            if (waveRadius >= effectiveDistTrainB && !trainDetectionB) {
                trainDetectionB = animationTime;
            }
            if (waveRadius >= effectiveDistTrainA && !trainDetectionA) {
                trainDetectionA = animationTime;
            }
        }
        
        function drawDetectionIndicators() {
            const trainCenter = centerX;
            
            // Train observer detection display (above the train)
            ctx.font = 'bold ' + (11 * scaleFactor) + 'px sans-serif';
            
            if (trainDetectionA && trainDetectionB) {
                const diff = trainDetectionA - trainDetectionB;
                ctx.fillStyle = '#34d399';
                ctx.textAlign = 'center';
                ctx.fillText(`Train: B detected ${diff.toFixed(3)}s before A (NOT simultaneous!)`, centerX, trainY - 60 * scaleFactor);
                ctx.textAlign = 'left';
            } else if (trainDetectionB && !trainDetectionA) {
                ctx.fillStyle = '#34d399';
                ctx.textAlign = 'center';
                ctx.fillText(`Train: B detected first! Waiting for A...`, centerX, trainY - 60 * scaleFactor);
                ctx.textAlign = 'left';
            }
            
            // Platform observer detection display (below the platform)
            if (platformDetectionA && platformDetectionB) {
                const diff = Math.abs(platformDetectionA - platformDetectionB);
                ctx.fillStyle = '#60a5fa';
                ctx.textAlign = 'center';
                ctx.fillText(`Platform: Both detected at same time! (Œît ‚âà ${diff.toFixed(3)}s)`, centerX, platformY + 60 * scaleFactor);
                ctx.textAlign = 'left';
            }
            
            // Detection markers on train observer (scaled)
            if (trainDetectionB) {
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(trainCenter + 18 * scaleFactor, trainY + trainHeight / 2 - 12 * scaleFactor, 7 * scaleFactor, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#0a0e1a';
                ctx.font = 'bold ' + (9 * scaleFactor) + 'px sans-serif';
                ctx.fillText('B', trainCenter + 14 * scaleFactor, trainY + trainHeight / 2 - 9 * scaleFactor);
            }
            
            if (trainDetectionA) {
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(trainCenter - 18 * scaleFactor, trainY + trainHeight / 2 - 12 * scaleFactor, 7 * scaleFactor, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#0a0e1a';
                ctx.font = 'bold ' + (9 * scaleFactor) + 'px sans-serif';
                ctx.fillText('A', trainCenter - 22 * scaleFactor, trainY + trainHeight / 2 - 9 * scaleFactor);
            }
        }
        
        function drawLabels() {
            const trainCenter = centerX;
            
            // Strike point labels (scaled)
            ctx.font = (11 * scaleFactor) + 'px sans-serif';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText('Strike A', trainCenter - trainLength / 2 - 25 * scaleFactor, trainY - 25 * scaleFactor);
            ctx.fillText('Strike B', trainCenter + trainLength / 2 - 25 * scaleFactor, trainY - 25 * scaleFactor);
            
            // Strike markers - vertical dashed lines from top to train
            ctx.strokeStyle = '#fbbf24';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1 * scaleFactor;
            
            ctx.beginPath();
            ctx.moveTo(trainCenter - trainLength / 2, trainY - 20 * scaleFactor);
            ctx.lineTo(trainCenter - trainLength / 2, trainY + trainHeight + 25 * scaleFactor);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(trainCenter + trainLength / 2, trainY - 20 * scaleFactor);
            ctx.lineTo(trainCenter + trainLength / 2, trainY + trainHeight + 25 * scaleFactor);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        function drawSpacetimeDiagram() {
            const diagW = spacetimeCanvas.width;
            const diagH = spacetimeCanvas.height;
            const padding = 20;
            
            // Clear
            stCtx.fillStyle = 'rgba(10, 14, 26, 0.9)';
            stCtx.fillRect(0, 0, diagW, diagH);
            
            // Axes
            stCtx.strokeStyle = '#4b5563';
            stCtx.lineWidth = 1;
            stCtx.beginPath();
            stCtx.moveTo(padding, diagH - padding);
            stCtx.lineTo(diagW - padding, diagH - padding);
            stCtx.moveTo(diagW / 2, diagH - padding);
            stCtx.lineTo(diagW / 2, padding);
            stCtx.stroke();
            
            stCtx.font = '10px sans-serif';
            stCtx.fillStyle = '#64748b';
            stCtx.fillText('x', diagW - padding - 5, diagH - padding + 15);
            stCtx.fillText('t', diagW / 2 + 8, padding + 5);
            
            // Light cones
            stCtx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
            stCtx.setLineDash([3, 3]);
            
            // From A
            stCtx.beginPath();
            stCtx.moveTo(padding + 20, diagH - padding);
            stCtx.lineTo(diagW / 2, diagH / 2);
            stCtx.stroke();
            
            // From B
            stCtx.beginPath();
            stCtx.moveTo(diagW - padding - 20, diagH - padding);
            stCtx.lineTo(diagW / 2, diagH / 2);
            stCtx.stroke();
            
            stCtx.setLineDash([]);
            
            // World lines
            // Platform observer (vertical)
            stCtx.strokeStyle = '#60a5fa';
            stCtx.lineWidth = 2;
            stCtx.beginPath();
            stCtx.moveTo(diagW / 2, diagH - padding);
            stCtx.lineTo(diagW / 2, padding);
            stCtx.stroke();
            
            // Train observer (tilted)
            stCtx.strokeStyle = '#34d399';
            stCtx.beginPath();
            stCtx.moveTo(diagW / 2, diagH - padding);
            stCtx.lineTo(diagW / 2 + trainVelocity * 60, padding);
            stCtx.stroke();
            
            // Events
            stCtx.fillStyle = '#fbbf24';
            stCtx.beginPath();
            stCtx.arc(padding + 20, diagH - padding, 5, 0, Math.PI * 2);
            stCtx.fill();
            stCtx.beginPath();
            stCtx.arc(diagW - padding - 20, diagH - padding, 5, 0, Math.PI * 2);
            stCtx.fill();
            
            // Labels
            stCtx.font = '9px sans-serif';
            stCtx.fillStyle = '#fbbf24';
            stCtx.fillText('A', padding + 15, diagH - padding - 10);
            stCtx.fillText('B', diagW - padding - 25, diagH - padding - 10);
        }
        
        let lastTime = 0;
        
        function animate(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (deltaTime < 0.1) {
                animationTime += deltaTime;
            }
            
            // Clear canvas
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw scene
            drawStars();
            drawLabels();
            drawPlatform();
            drawTrain();
            drawLightning();
            drawDetectionIndicators();
            drawSpacetimeDiagram();
            
            // Update stats
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        requestAnimationFrame(animate);
    </script>
</body>
</html>