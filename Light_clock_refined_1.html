<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Light Clock - Time Dilation Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0a0e1a; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #e2e8f0;
        }
        
        .top-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 320px;
            height: 50px;
            background: rgba(10, 14, 26, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            display: flex;
            align-items: center;
            padding: 0 25px;
            z-index: 1001;
        }
        
        .header-title {
            font-size: 20px;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 320px;
            bottom: 0;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .control-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%;
            background: rgba(10, 14, 26, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .panel-title {
            font-size: 20px;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-subtitle {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 25px;
        }
        
        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .stat {
            background: rgba(148, 163, 184, 0.05);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .stat-label {
            color: #64748b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            min-height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stat-value {
            color: #f1f5f9;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            font-size: 18px;
        }
        
        .stat-value.highlight {
            color: #60a5fa;
        }
        
        .stat-value.warning {
            color: #fbbf24;
        }
        
        .time-diff-display {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin-top: 15px;
        }
        
        .time-diff-label {
            color: #64748b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }
        
        .time-diff-value {
            color: #fbbf24;
            font-weight: 600;
            font-size: 14px;
        }
        
        .control {
            margin-bottom: 20px;
        }
        
        .control label {
            display: block;
            font-size: 11px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .slider-value {
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
            min-width: 50px;
            text-align: right;
        }
        
        .btn {
            width: 100%;
            padding: 12px 16px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            color: #60a5fa;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .about-text {
            color: #94a3b8;
            font-size: 12px;
            line-height: 1.7;
        }
        
        .about-text p {
            margin-bottom: 10px;
        }
        
        .about-text p:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="top-header">
        <div class="header-title">ðŸš‚ Light Clock on Trains</div>
    </div>
    
    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>
    
    <div class="control-panel">
        <div class="panel-title">Controls</div>
        <div class="panel-subtitle">Special Relativity & Time Dilation</div>
        
        <div class="section">
            <div class="section-title">Statistics</div>
            <div class="stat-grid">
                <div class="stat">
                    <div class="stat-label">Velocity</div>
                    <div class="stat-value highlight" id="velocityDisplay">0.00c</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Î³ (Gamma)</div>
                    <div class="stat-value warning" id="gammaDisplay">1.000</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Rest Frame Ticks</div>
                    <div class="stat-value" id="stationaryTicks">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Moving Frame Ticks</div>
                    <div class="stat-value" id="movingTicks">0</div>
                </div>
            </div>
            <div class="time-diff-display">
                <div class="time-diff-label">Time Dilation Effect</div>
                <div class="time-diff-value" id="timeDiffDisplay">Moving clock runs at same speed</div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Controls</div>
            <div class="control">
                <label>Velocity (% of speed of light)</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="velocitySlider" min="0" max="99" value="0">
                    <span class="slider-value" id="velocityValue">0%</span>
                </div>
            </div>
            <div class="control">
                <label>Animation Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="speedSlider" min="25" max="200" value="100">
                    <span class="slider-value" id="speedValue">1.0x</span>
                </div>
            </div>
            <button class="btn" id="resetBtn">Reset Clocks</button>
        </div>
        
        <div class="section">
            <div class="section-title">About the Simulation</div>
            <div class="about-text">
                <p>This simulation shows Einstein's light clock thought experiment using trains.</p>
                <p><strong>Rest Frame (Left):</strong> Shows a single stationary train with a photon bouncing straight up and down between mirrors.</p>
                <p><strong>Moving Frame (Right):</strong> When stationary, shows identical behavior to the rest frame. As velocity increases, 3 train positions appear showing the photon's diagonal path.</p>
                <p>The diagonal path is longer, so time must dilate for the moving observer!</p>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        
        // Physics parameters
        let velocity = 0;
        let targetVelocity = 0;
        let gamma = 1;
        let animationSpeed = 1;
        
        // Clock states
        const clockHeight = 160;
        const mirrorWidth = 60;
        const trainWidth = 120;
        const trainHeight = 200;
        
        // Stationary clock (rest frame)
        let stationaryPhotonY = 0;
        let stationaryDirection = 1;
        let stationaryTickCount = 0;
        
        // Moving clock - single train mode (when stationary)
        let movingPhotonY = 0;
        let movingDirection = 1;
        
        // Moving clock - three train mode (when moving)
        let movingPhotonProgress = 0; // 0 to 2 (0-1: first leg, 1-2: second leg)
        let movingTickCount = 0;
        
        // Threshold for switching between single and triple train display
        const velocityThreshold = 0.02;
        
        // Animation
        const baseSpeed = 2;
        let lastTime = 0;
        
        // Trail effect for photons
        const stationaryTrail = [];
        const movingTrail = [];
        const maxTrailLength = 25;
        
        // Smoothing factor
        const velocitySmoothingFactor = 0.05;
        
        // Stars for background
        const stars = [];
        const numStars = 150;
        
        // Animation time for effects
        let animTime = 0;
        
        // Wheel animation
        let wheelRotation = 0;
        
        function initStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random(),
                    y: Math.random(),
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random() * 0.5 + 0.5
                });
            }
        }
        
        function resize() {
            const container = document.getElementById('canvas-container');
            width = canvas.width = container.offsetWidth;
            height = canvas.height = container.offsetHeight;
            initStars();
        }
        
        function calculateGamma(v) {
            if (v >= 1) return Infinity;
            return 1 / Math.sqrt(1 - v * v);
        }
        
        function drawStars(startX, endX, isMoving, starOffset = 0) {
            const frameWidth = endX - startX;
            
            for (let star of stars) {
                let starX;
                if (isMoving) {
                    starX = startX + ((star.x * frameWidth - starOffset) % frameWidth + frameWidth) % frameWidth;
                } else {
                    starX = startX + star.x * frameWidth;
                }
                const starY = star.y * height;
                
                if (starX >= startX && starX <= endX) {
                    ctx.beginPath();
                    ctx.arc(starX, starY, star.size, 0, Math.PI * 2);
                    const alpha = star.brightness * (isMoving ? 0.8 : 1);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fill();
                    
                    if (star.brightness > 0.7) {
                        ctx.beginPath();
                        ctx.arc(starX, starY, star.size * 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.2})`;
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawTrain(x, y, color, alpha = 1, isMoving = false) {
            const tw = trainWidth;
            const th = trainHeight;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Train body - main carriage
            const bodyGrad = ctx.createLinearGradient(x - tw/2, y - th/2, x - tw/2, y + th/2);
            bodyGrad.addColorStop(0, 'rgba(80, 60, 40, 0.7)');
            bodyGrad.addColorStop(0.3, 'rgba(120, 90, 60, 0.8)');
            bodyGrad.addColorStop(0.7, 'rgba(100, 75, 50, 0.8)');
            bodyGrad.addColorStop(1, 'rgba(70, 50, 35, 0.7)');
            
            // Main body rectangle
            ctx.beginPath();
            ctx.roundRect(x - tw/2, y - th/2 + 20, tw, th - 60, 8);
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(180, 150, 100, 0.9)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Roof
            ctx.beginPath();
            ctx.moveTo(x - tw/2 - 5, y - th/2 + 20);
            ctx.quadraticCurveTo(x, y - th/2 - 10, x + tw/2 + 5, y - th/2 + 20);
            ctx.lineTo(x + tw/2, y - th/2 + 25);
            ctx.lineTo(x - tw/2, y - th/2 + 25);
            ctx.closePath();
            const roofGrad = ctx.createLinearGradient(x, y - th/2 - 10, x, y - th/2 + 25);
            roofGrad.addColorStop(0, 'rgba(60, 45, 30, 0.8)');
            roofGrad.addColorStop(1, 'rgba(90, 70, 50, 0.8)');
            ctx.fillStyle = roofGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(150, 120, 80, 0.9)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Windows (3 windows vertically)
            const windowWidth = tw * 0.6;
            const windowHeight = 35;
            const windowSpacing = 45;
            const windowStartY = y - th/2 + 50;
            
            for (let i = 0; i < 3; i++) {
                const wy = windowStartY + i * windowSpacing;
                
                // Window frame
                ctx.beginPath();
                ctx.roundRect(x - windowWidth/2 - 3, wy - 3, windowWidth + 6, windowHeight + 6, 4);
                ctx.fillStyle = 'rgba(60, 50, 40, 0.9)';
                ctx.fill();
                
                // Window glass
                ctx.beginPath();
                ctx.roundRect(x - windowWidth/2, wy, windowWidth, windowHeight, 3);
                const windowGrad = ctx.createLinearGradient(x - windowWidth/2, wy, x + windowWidth/2, wy + windowHeight);
                windowGrad.addColorStop(0, 'rgba(100, 150, 200, 0.6)');
                windowGrad.addColorStop(0.3, 'rgba(150, 200, 240, 0.7)');
                windowGrad.addColorStop(0.7, 'rgba(120, 170, 220, 0.6)');
                windowGrad.addColorStop(1, 'rgba(80, 130, 180, 0.5)');
                ctx.fillStyle = windowGrad;
                ctx.fill();
                ctx.strokeStyle = 'rgba(200, 180, 140, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Window reflection
                ctx.beginPath();
                ctx.moveTo(x - windowWidth/2 + 5, wy + 5);
                ctx.lineTo(x - windowWidth/2 + 15, wy + 5);
                ctx.lineTo(x - windowWidth/2 + 8, wy + 12);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }
            
            // Decorative stripe
            ctx.beginPath();
            ctx.rect(x - tw/2, y + 20, tw, 8);
            ctx.fillStyle = 'rgba(180, 140, 60, 0.8)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(220, 180, 100, 0.9)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Bottom platform
            ctx.beginPath();
            ctx.rect(x - tw/2 - 10, y + th/2 - 40, tw + 20, 15);
            ctx.fillStyle = 'rgba(50, 40, 30, 0.9)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(100, 80, 60, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Wheels
            const wheelRadius = 18;
            const wheelY = y + th/2 - 15;
            const wheelPositions = [x - tw/3, x, x + tw/3];
            
            // Determine wheel rotation based on whether this is a moving train
            const currentWheelRotation = isMoving ? wheelRotation : 0;
            
            for (let wx of wheelPositions) {
                // Wheel shadow
                ctx.beginPath();
                ctx.ellipse(wx + 3, wheelY + 3, wheelRadius, wheelRadius * 0.8, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                
                // Main wheel
                ctx.beginPath();
                ctx.arc(wx, wheelY, wheelRadius, 0, Math.PI * 2);
                const wheelGrad = ctx.createRadialGradient(wx - 5, wheelY - 5, 0, wx, wheelY, wheelRadius);
                wheelGrad.addColorStop(0, 'rgba(80, 80, 90, 1)');
                wheelGrad.addColorStop(0.7, 'rgba(50, 50, 60, 1)');
                wheelGrad.addColorStop(1, 'rgba(30, 30, 40, 1)');
                ctx.fillStyle = wheelGrad;
                ctx.fill();
                ctx.strokeStyle = 'rgba(120, 120, 130, 0.9)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Wheel spokes
                ctx.save();
                ctx.translate(wx, wheelY);
                ctx.rotate(currentWheelRotation);
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, wheelRadius - 4);
                    ctx.strokeStyle = 'rgba(100, 100, 110, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
                
                // Wheel center hub
                ctx.beginPath();
                ctx.arc(wx, wheelY, 6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(150, 150, 160, 1)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(200, 200, 210, 0.8)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Rails/tracks
            ctx.beginPath();
            ctx.rect(x - tw/2 - 30, wheelY + wheelRadius + 2, tw + 60, 6);
            ctx.fillStyle = 'rgba(80, 70, 60, 0.8)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(120, 110, 100, 0.7)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Rail ties
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.rect(x + i * 20 - 4, wheelY + wheelRadius + 8, 8, 4);
                ctx.fillStyle = 'rgba(60, 50, 40, 0.7)';
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawMirror(x, y, w) {
            // Prominent, bright mirrors
            const gradient = ctx.createLinearGradient(x - w/2, y, x + w/2, y);
            gradient.addColorStop(0, 'rgba(100, 180, 255, 0.3)');
            gradient.addColorStop(0.2, 'rgba(150, 220, 255, 0.9)');
            gradient.addColorStop(0.5, 'rgba(200, 240, 255, 1)');
            gradient.addColorStop(0.8, 'rgba(150, 220, 255, 0.9)');
            gradient.addColorStop(1, 'rgba(100, 180, 255, 0.3)');
            
            // Mirror glow effect
            ctx.beginPath();
            ctx.rect(x - w/2 - 5, y - 8, w + 10, 16);
            const glowGrad = ctx.createRadialGradient(x, y, 0, x, y, w/2);
            glowGrad.addColorStop(0, 'rgba(150, 220, 255, 0.4)');
            glowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGrad;
            ctx.fill();
            
            // Main mirror body
            ctx.fillStyle = gradient;
            ctx.fillRect(x - w/2, y - 5, w, 10);
            
            // Bright border
            ctx.strokeStyle = 'rgba(200, 240, 255, 1)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - w/2, y - 5, w, 10);
            
            // Inner highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(x - w/2 + 5, y - 2, w - 10, 4);
        }
        
        function drawPhoton(x, y, color, trail, size = 8) {
            trail.push({x, y, alpha: 1});
            if (trail.length > maxTrailLength) trail.shift();
            
            // Draw trail
            for (let i = 0; i < trail.length; i++) {
                const t = trail[i];
                const alpha = Math.pow(i / trail.length, 0.5) * 0.6;
                const trailSize = 2 + (i / trail.length) * 3;
                ctx.beginPath();
                ctx.arc(t.x, t.y, trailSize, 0, Math.PI * 2);
                ctx.fillStyle = color.replace('1)', alpha + ')');
                ctx.fill();
            }
            
            // Draw main photon
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 1.5);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, color);
            gradient.addColorStop(0.7, color.replace('1)', '0.5)'));
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Glow effect
            ctx.beginPath();
            ctx.arc(x, y, size * 2.5, 0, Math.PI * 2);
            const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
            glowGradient.addColorStop(0, color.replace('1)', '0.4)'));
            glowGradient.addColorStop(0.5, color.replace('1)', '0.15)'));
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.fill();
        }
        
        function drawRestFrame(centerX, centerY) {
            // Draw single train - rest frame train is NOT moving
            const trainX = centerX;
            const trainY = centerY;
            
            drawTrain(trainX, trainY, 'rgba(59, 130, 246, 0.3)', 1, false);
            
            // Mirror positions inside train
            const topMirrorY = trainY - clockHeight/2;
            const bottomMirrorY = trainY + clockHeight/2;
            
            // Draw mirrors - now more prominent
            drawMirror(trainX, topMirrorY, mirrorWidth);
            drawMirror(trainX, bottomMirrorY, mirrorWidth);
            
            // Draw vertical path indicator
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(trainX, topMirrorY);
            ctx.lineTo(trainX, bottomMirrorY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Calculate photon position (straight up and down)
            const photonY = topMirrorY + stationaryPhotonY;
            
            // Draw photon
            drawPhoton(trainX, photonY, 'rgba(96, 165, 250, 1)', stationaryTrail, 8);
            
            // Label
            ctx.fillStyle = '#94a3b8';
            ctx.font = '13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('REST FRAME', centerX, centerY + trainHeight/2 + 60);
            ctx.fillStyle = '#64748b';
            ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText('Photon bounces straight', centerX, centerY + trainHeight/2 + 80);
        }
        
        function drawMovingFrameSingleTrain(centerX, centerY) {
            // Draw single train (identical to rest frame) - NOT moving when velocity is low
            const trainX = centerX;
            const trainY = centerY;
            
            drawTrain(trainX, trainY, 'rgba(244, 114, 182, 0.3)', 1, false);
            
            // Mirror positions inside train
            const topMirrorY = trainY - clockHeight/2;
            const bottomMirrorY = trainY + clockHeight/2;
            
            // Draw mirrors - now more prominent
            drawMirror(trainX, topMirrorY, mirrorWidth);
            drawMirror(trainX, bottomMirrorY, mirrorWidth);
            
            // Draw vertical path indicator
            ctx.strokeStyle = 'rgba(244, 114, 182, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(trainX, topMirrorY);
            ctx.lineTo(trainX, bottomMirrorY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Calculate photon position (straight up and down)
            const photonY = topMirrorY + movingPhotonY;
            
            // Draw photon
            drawPhoton(trainX, photonY, 'rgba(244, 114, 182, 1)', movingTrail, 8);
            
            // Label
            ctx.fillStyle = '#94a3b8';
            ctx.font = '13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('MOVING FRAME', centerX, centerY + trainHeight/2 + 60);
            ctx.fillStyle = '#64748b';
            ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText('Photon bounces straight (at rest)', centerX, centerY + trainHeight/2 + 80);
        }
        
        function drawMovingFrameThreeTrains(centerX, centerY) {
            // Calculate spacing between trains based on velocity
            const trainSpacing = 100 + velocity * 80;
            
            // Three train positions
            const train1X = centerX - trainSpacing;
            const train2X = centerX;
            const train3X = centerX + trainSpacing;
            const trainY = centerY;
            
            // Mirror Y positions
            const topMirrorY = trainY - clockHeight/2;
            const bottomMirrorY = trainY + clockHeight/2;
            
            // Draw all three trains with decreasing opacity - these ARE moving
            drawTrain(train1X, trainY, 'rgba(244, 114, 182, 0.2)', 0.6, true);
            drawTrain(train2X, trainY, 'rgba(244, 114, 182, 0.3)', 0.8, true);
            drawTrain(train3X, trainY, 'rgba(244, 114, 182, 0.2)', 0.6, true);
            
            // Draw mirrors on all trains - now more prominent
            drawMirror(train1X, topMirrorY, mirrorWidth);
            drawMirror(train1X, bottomMirrorY, mirrorWidth);
            
            drawMirror(train2X, topMirrorY, mirrorWidth);
            drawMirror(train2X, bottomMirrorY, mirrorWidth);
            
            drawMirror(train3X, topMirrorY, mirrorWidth);
            drawMirror(train3X, bottomMirrorY, mirrorWidth);
            
            // Draw the diagonal path
            ctx.strokeStyle = 'rgba(244, 114, 182, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Path from train1 bottom to train2 top
            ctx.beginPath();
            ctx.moveTo(train1X, bottomMirrorY);
            ctx.lineTo(train2X, topMirrorY);
            ctx.stroke();
            
            // Path from train2 top to train3 bottom
            ctx.beginPath();
            ctx.moveTo(train2X, topMirrorY);
            ctx.lineTo(train3X, bottomMirrorY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Calculate photon position along diagonal path
            let photonX, photonY;
            
            if (movingPhotonProgress <= 1) {
                // First leg: train1 bottom to train2 top
                const t = movingPhotonProgress;
                photonX = train1X + (train2X - train1X) * t;
                photonY = bottomMirrorY + (topMirrorY - bottomMirrorY) * t;
            } else {
                // Second leg: train2 top to train3 bottom
                const t = movingPhotonProgress - 1;
                photonX = train2X + (train3X - train2X) * t;
                photonY = topMirrorY + (bottomMirrorY - topMirrorY) * t;
            }
            
            // Draw active path segment
            ctx.strokeStyle = 'rgba(244, 114, 182, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            if (movingPhotonProgress <= 1) {
                ctx.moveTo(train1X, bottomMirrorY);
                ctx.lineTo(photonX, photonY);
            } else {
                ctx.moveTo(train1X, bottomMirrorY);
                ctx.lineTo(train2X, topMirrorY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(train2X, topMirrorY);
                ctx.lineTo(photonX, photonY);
            }
            ctx.stroke();
            
            // Draw photon
            drawPhoton(photonX, photonY, 'rgba(244, 114, 182, 1)', movingTrail, 8);
            
            // Train position labels
            ctx.fillStyle = '#64748b';
            ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('tâ‚', train1X, trainY + trainHeight/2 + 45);
            ctx.fillText('tâ‚‚', train2X, trainY + trainHeight/2 + 45);
            ctx.fillText('tâ‚ƒ', train3X, trainY + trainHeight/2 + 45);
            
            // Main label
            ctx.fillStyle = '#94a3b8';
            ctx.font = '13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText('MOVING FRAME', centerX, centerY + trainHeight/2 + 65);
            ctx.fillStyle = '#64748b';
            ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText('Photon travels diagonally', centerX, centerY + trainHeight/2 + 85);
            
            ctx.fillStyle = '#f472b6';
            ctx.fillText(`v = ${(velocity * 100).toFixed(0)}% c â†’`, centerX, centerY + trainHeight/2 + 105);
        }
        
        function drawDividerLine() {
            const centerX = width / 2;
            
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            const gradient = ctx.createLinearGradient(centerX - 20, 0, centerX + 20, 0);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.5, 'rgba(148, 163, 184, 0.1)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(centerX - 20, 0, 40, height);
        }
        
        // Star offset for animation
        let starOffset = 0;
        
        function update(deltaTime) {
            // Update animation time
            animTime += deltaTime * 0.001;
            
            // Smooth velocity transitions
            velocity += (targetVelocity - velocity) * velocitySmoothingFactor;
            gamma = calculateGamma(velocity);
            
            // Update star offset for moving frame
            starOffset += velocity * 3 * animationSpeed;
            
            // Update wheel rotation (only for moving trains)
            wheelRotation += velocity * 0.2 * animationSpeed;
            
            // Update display values
            document.getElementById('velocityDisplay').textContent = velocity.toFixed(2) + 'c';
            document.getElementById('gammaDisplay').textContent = gamma.toFixed(3);
            
            // Update time difference display
            const timeDiffDisplay = document.getElementById('timeDiffDisplay');
            if (velocity > 0.01) {
                const timeDiff = ((gamma - 1) * 100).toFixed(1);
                timeDiffDisplay.textContent = `Moving clock runs ${timeDiff}% slower`;
            } else {
                timeDiffDisplay.textContent = 'Moving clock runs at same speed';
            }
            
            const speed = baseSpeed * animationSpeed;
            
            // Update stationary clock (straight up and down)
            stationaryPhotonY += speed * stationaryDirection;
            
            if (stationaryPhotonY >= clockHeight) {
                stationaryPhotonY = clockHeight;
                stationaryDirection = -1;
                stationaryTickCount++;
            } else if (stationaryPhotonY <= 0) {
                stationaryPhotonY = 0;
                stationaryDirection = 1;
                stationaryTickCount++;
            }
            
            // Update moving clock based on velocity
            if (velocity < velocityThreshold) {
                // Single train mode - identical to rest frame
                movingPhotonY += speed * movingDirection;
                
                if (movingPhotonY >= clockHeight) {
                    movingPhotonY = clockHeight;
                    movingDirection = -1;
                    movingTickCount++;
                } else if (movingPhotonY <= 0) {
                    movingPhotonY = 0;
                    movingDirection = 1;
                    movingTickCount++;
                }
            } else {
                // Three train mode - diagonal path, time dilated
                const dilatedSpeed = (speed / clockHeight) / gamma;
                movingPhotonProgress += dilatedSpeed;
                
                if (movingPhotonProgress >= 2) {
                    movingPhotonProgress = 0;
                    movingTickCount += 2; // One full cycle = 2 bounces
                    movingTrail.length = 0; // Clear trail on reset
                }
            }
        }
        
        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Draw stars
            drawStars(0, centerX, false, 0);
            drawStars(centerX, width, velocity >= velocityThreshold, starOffset);
            
            // Draw divider
            drawDividerLine();
            
            // Draw frames
            drawRestFrame(width * 0.25, centerY);
            
            // Draw moving frame based on velocity
            if (velocity < velocityThreshold) {
                drawMovingFrameSingleTrain(width * 0.75, centerY);
            } else {
                drawMovingFrameThreeTrains(width * 0.75, centerY);
            }
            
            // Update tick displays
            document.getElementById('stationaryTicks').textContent = Math.floor(stationaryTickCount / 2);
            document.getElementById('movingTicks').textContent = Math.floor(movingTickCount / 2);
        }
        
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        const velocitySlider = document.getElementById('velocitySlider');
        velocitySlider.addEventListener('input', (e) => {
            targetVelocity = e.target.value / 100;
            document.getElementById('velocityValue').textContent = e.target.value + '%';
            
            // When transitioning from single to triple train mode, sync the photon position
            if (targetVelocity >= velocityThreshold && velocity < velocityThreshold) {
                // Convert vertical position to progress
                if (movingDirection === 1) {
                    movingPhotonProgress = movingPhotonY / clockHeight;
                } else {
                    movingPhotonProgress = 1 + (1 - movingPhotonY / clockHeight);
                }
                movingTrail.length = 0;
            }
        });
        
        const speedSlider = document.getElementById('speedSlider');
        speedSlider.addEventListener('input', (e) => {
            animationSpeed = e.target.value / 100;
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            stationaryPhotonY = 0;
            stationaryDirection = 1;
            stationaryTickCount = 0;
            movingPhotonY = 0;
            movingDirection = 1;
            movingPhotonProgress = 0;
            movingTickCount = 0;
            starOffset = 0;
            stationaryTrail.length = 0;
            movingTrail.length = 0;
        });
        
        // Initialize
        window.addEventListener('resize', resize);
        resize();
        
        // Start animation
        requestAnimationFrame(animate);
    </script>
</body>
</html>